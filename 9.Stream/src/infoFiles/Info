    <<Промежуточные операции>>
filter (Predicate) – оставляет только таким элементы, которые соответствуют Предикату;
map (Function) – применяет функцию ко всем элементам потока (позволяет преобразовать из одного типа в другой);
flatMap (Fuction<T, ? extends Stream>) – позволяет из одного элемента получить несколько (например, из List<List<Integer>> получить Stream<Integer>.

limit(int) – позволяет ограничить количество элементов в потоке;
skip(int) – позволяет пропустить некоторое количество элементов;
distinct – исключает дубликаты;
sorted – сортирует элементы в стриме;
sorted (Comparator) – сортирует с помощью указанного компаратора;
takeWhile (Predicate) – извлекают элементы из упорядоченного потока до тех пор, пока условие предиката истинно;
dropWhile (Predicate) – пропускает элементы из упорядоченного потока до тех пор, пока условие истинно. Остальные элементы не проверяются.

    <<Терминальные операции>>
void forEach(Consumer) – применяет Consumer к каждому элементу
boolean anyMatch(Predicate) – хотя бы один элемент удовлетворяет предикату;
boolean allMatch(Predicate) – все элементы удовлетворяют Предикату;
boolean noneMatch(Predicate) – ни один элемент не удовлетворяет предикату (в таком случае результат true)
Optional<T> findFirst – возвращает первый элемент по порядку следования в потоке, не зависит от использования параллельного стрима;
Optional<T> findAny – возвращает первый элемент по порядку следования в последовательном потоке, любой – в параллельном потоке (необязательно первый);
Optional<T> min / max – максимальный / минимальный элемент;
long count – количество элементов в потоке.

    <<Optional>>
Optional служит оболочкой для объекта определенного типа. Позволяет определять, присутствует значение или отсутствует.
Используется в тех случаях, когда возвращаемое значение может быть, а может нет (в таком случае Optional будет оберткой для null).
Позволяет избежать NPE из-за того, что метод вернул null.
Optional.of (T) – оборачивает значение. Если значение равно null, бросает NullPointerException;
Optional.empty – создает пустую обертку;
Optional.ofNullable (T) – оборачивает значение. Если значение равно null, оборачивает его в Optional.empty();
boolean isPresent – проверяет на не пустоту.
void ifPresent (Consumer) – применяет операцию Consumer, если значение присутствует;
void ifPresentOrElse (Consumer, Runnable) – применяет операцию Consumer, если значение присутствует, иначе выполняет Runnable (лямбда без параметров и возвращаемого значения);
get – получает значение из Optional. Если значения нет, то генерирует исключение NoSuchElementException;
orElse (T default) – получает значение из Optional. Если значения нет, возвращает значение default;
orElseGet (Supplier) – получает значение из Optional. Если значения нет, то возвращает результат выполнения Supplier.

    <<Примитивные стримы>>
sum – находит сумму стрима (терминальная операция);
average – находит среднее стрима (терминальная операция);
mapToObj (Function) – преобразует примитивный стрим в любой параметризированный стрим (тип определяет Function);
boxed – оборачивает в соответствующий класс-обертку для примитивного типа стрима;
range (begin, end) – последовательность с шагом 1 (промежуточная операция, только для IntStream).

    <<Коллекторы>>
Класс Collectors позволяет преобразовать поток в определенную коллекцию, а также предоставляет некоторые другие полезные средства. Коллектор передается в терминальный метод collect.
Основные методы:
toList – преобразует поток в список;
toSet – преобразует поток в множество;
toMap (Function key, Function value) – преобразует поток в отображение;
toCollection (Supplier) – преобразует поток в любую коллекцию, определенную через Supplier.

String joining – обрабатывает стрим String, соединяя стрим строк в одну строку;
Long counting – считает количество элементов;
double / int / long summing – считает сумму элементов;
double averaging – считает среднее элементов;
Optional maxBy / minBy (Comparator) – возвращает максимальный / минимальный элементов стрима;
Collector <Map<K, V>> groupingBy – позволяет сгруппировать ключи по одному из агрегирующих признаков (сумма, среднее, максимум, минимум, количество). Первый параметр – ключ, второй – агрегирующая функция из класса Collectors.

